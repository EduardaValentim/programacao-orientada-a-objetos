	Ramificação(Branching), no controle de versão e no gerenciamento de configuração de software, é a duplicação de um objeto sob controle de versão (como um arquivo de código-fonte ou uma árvore de diretórios ), para que modificações possam ocorrer em paralelo ao longo de várias ramificações .
	Ramos também são conhecidos como árvores, córregos ou linhas de código. Às vezes, a ramificação de origem é chamada ramificação pai, ramificação upstream (ou simplesmente upstream, especialmente se as ramificações são mantidas por diferentes organizações ou indivíduos) ou o backing stream. Filiais filhas são filiais que têm um pai; uma ramificação sem pai é chamada de tronco ou linha principal .
	A ramificação também geralmente implica a capacidade de mesclar ou integrar posteriormente as alterações na ramificação pai. Geralmente, as alterações são mescladas de volta ao tronco, mesmo que esse não seja o ramo pai. Uma filial que não pretende ser mesclada (por exemplo, porque foi relicenciada por uma licença incompatível por terceiros ou tenta servir a um propósito diferente) é geralmente chamada de fork.
	As ramificações permitem que partes do software sejam desenvolvidas em paralelo. Grandes projetos exigem que muitas funções sejam preenchidas, incluindo desenvolvedores, gerentes de construção e pessoal de garantia de qualidade . Além disso, várias versões em diferentes plataformas de sistema operacional podem precisar ser mantidas. Permiti ramos que contribuintes para isolar alterações sem desestabilizar a base de código, por exemplo, corrige para bugs, novas funcionalidades, e versões integração . Essas alterações podem ser mescladas posteriormente (ressincronizadas) após o teste.
	Em projetos que usam Git, podemos ter tanto branches locais, presentes apenas na máquina do programador, quanto branches remotas, que apontam para outras máquinas. Por padrão, a branch principal é chamada master, tanto no repositório local quanto no remoto. Idealmente, a master será uma branch estável, isto é, o código nessa branch estará testado e pronto para ser entregue.
	Para compreender realmente a forma como o Git cria branches, precisamos dar um passo atrás e examinar como o Git armazena seus dados. O Git não armazena dados como uma série de mudanças ou deltas, mas sim como uma série de snapshots.
Quando você faz um commit no Git, o Git guarda um objeto commit que contém um ponteiro para o snapshot do conteúdo que você colocou na área de seleção, o autor e os metadados da mensagem, zero ou mais ponteiros para o commit ou commits que são pais deste commit: nenhum pai para o commit inicial, um pai para um commit normal e múltiplos pais para commits que resultem de um merge de dois ou mais branches.
	você cria um commit, o Git calcula o checksum de cada subdiretório (neste caso, apenas o diretório raiz do projeto) e armazena os objetos de árvore no repositório Git. O Git em seguida, cria um objeto commit que tem os metadados e um ponteiro para a árvore do projeto raiz, então ele pode recriar este snapshot quando necessário.
Se você modificar algumas coisas e fizer um commit novamente, o próximo commit armazenará um ponteiro para o commit imediatamente anterior.
